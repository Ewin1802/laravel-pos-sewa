Berikut **single prompt** siap-copas ke Claude Code/Codex untuk mengerjakan sisi Laravel-nya. Fokus: tambah **/api/v1/time** dan **lengkapi payload issue license** agar klien bisa pakai aturan “harus online tiap 72 jam” + anti-backdate.

````text
Act as a senior Laravel 12 engineer. Apply the following changes in a clean, production-ready way. Keep PSR-12, add PHPDoc, and do NOT break existing APIs.

# GOALS
1) Tambah endpoint GET /api/v1/time yang mengembalikan epoch ms server + signature HMAC.
2) Lengkapi response “issue license” agar klien punya field yang konsisten dan mudah dipakai:
   - expires_at_ms (epoch ms)
   - plan_code, is_trial (sudah ada, pertahankan)
   - subscription_status (sudah ada)
   - device (sudah ada)
   - license_token (sudah ada)
   - server_time (sudah ada dari BaseApiController)
   - OPTIONAL: license_id atau subscription_id bila tersedia, hanya jika mudah diambil.
3) Signature HMAC pakai secret .env(APP_LICENSE_SECRET). Jika belum ada, buat config/license.php.

# IMPLEMENTATION DETAILS

## 1) Config & ENV
- Tambah file config/license.php:
  ```php
  <?php

  return [
      'secret' => env('APP_LICENSE_SECRET', ''),
      'time_sig_algo' => 'sha256',
  ];
````

* Pastikan .env memiliki:

  ```
  APP_LICENSE_SECRET=change_this_to_a_long_random_secret
  ```
* Tambahkan ke config/app.php kalau perlu publish/merge (tidak wajib jika hanya memakai config('license.secret')).

## 2) TimeController

Buat controller: app/Http/Controllers/Api/V1/TimeController.php
Tugas: kembalikan `server_epoch_ms` (int), `sig` (base64 HMAC), dan pakai BaseApiController::successResponse sehingga ada `server_time` ISO juga.

Kode contoh:

```php
<?php

namespace App\Http\Controllers\Api\V1;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;

class TimeController extends BaseApiController
{
    /**
     * GET /api/v1/time
     * Response:
     * {
     *   "success": true,
     *   "data": {
     *     "server_epoch_ms": 1738212345678,
     *     "sig": "base64(hmac_sha256(server_epoch_ms, APP_LICENSE_SECRET))"
     *   },
     *   "message": "Success",
     *   "code": 200,
     *   "server_time": "2025-09-29T07:55:12.345Z"
     * }
     */
    public function now(Request $request)
    {
        $ms = (int) round(microtime(true) * 1000);

        $secret = config('license.secret');
        if (empty($secret)) {
            return $this->errorResponse('License secret is not configured', 500);
        }

        // payload yang ditandatangani cukup angka epoch ms agar klien mudah verifikasi
        $payload = (string) $ms;
        $rawSig = hash_hmac(config('license.time_sig_algo', 'sha256'), $payload, $secret, true);
        $sig = base64_encode($rawSig);

        return $this->successResponse([
            'server_epoch_ms' => $ms,
            'sig' => $sig,
        ]);
    }
}
```

## 3) Routes

Di routes/api.php, tambahkan grup v1 bila belum, dan daftarkan route time:

```php
use App\Http\Controllers\Api\V1\TimeController;

Route::prefix('v1')->group(function () {
    // Jika API Anda butuh auth untuk time, bungkus dengan middleware auth:sanctum.
    // Untuk kasus ini boleh public karena hanya memberikan waktu + signature.
    Route::get('/time', [TimeController::class, 'now'])->name('api.v1.time');
});
```

## 4) Lengkapi response Issue License

Lokasi controller penerbitan license: (SESUAI kode proyek Anda), edit method yang mengembalikan “License issued successfully”.

* Tambahkan field `expires_at_ms` = `$licenseToken->expires_at->getTimestamp() * 1000`.
* Pertahankan field lama agar BE/FE lama tidak rusak.
* Jika mudah, tambahkan `license_id` (id license token atau subscription id).
* Jangan ubah format BaseApiController (sudah menyertakan `server_time` ISO).

Contoh patch minimal:

```php
// sebelum: return $this->successResponse([...], 'License issued successfully');

$data = [
    'license_token' => $licenseToken->getAttribute('plain_token'),
    'expires_at' => $licenseToken->expires_at, // keep original for backward compatibility
    'expires_at_ms' => $licenseToken->expires_at ? $licenseToken->expires_at->getTimestamp() * 1000 : null,
    'device' => $device,
    'subscription_status' => $subscription->status,
    'plan_code' => $subscription->isTrial() ? 'TRIAL' : $subscription->plan->code,
    'is_trial' => $subscription->isTrial(),
];

// OPTIONAL if available:
// $data['license_id'] = $licenseToken->id ?? null;
// $data['subscription_id'] = $subscription->id ?? null;

return $this->successResponse($data, 'License issued successfully');
```

## 5) Tests (Feature)

Tambahkan dua Feature test ringkas:

tests/Feature/Api/V1/TimeEndpointTest.php

```php
<?php

namespace Tests\Feature\Api\V1;

use Tests\TestCase;

class TimeEndpointTest extends TestCase
{
    public function test_time_endpoint_returns_epoch_and_sig(): void
    {
        $resp = $this->getJson('/api/v1/time');
        $resp->assertStatus(200)
            ->assertJsonPath('success', true)
            ->assertJsonStructure([
                'success',
                'data' => ['server_epoch_ms', 'sig'],
                'message',
                'code',
                'server_time',
            ]);

        $data = $resp->json('data');
        $this->assertIsInt($data['server_epoch_ms']);
        $this->assertNotEmpty($data['sig']);
    }
}
```

tests/Feature/Api/V1/LicenseIssueResponseTest.php

```php
<?php

namespace Tests\Feature\Api\V1;

use Tests\TestCase;

class LicenseIssueResponseTest extends TestCase
{
    public function test_issue_license_contains_expires_at_ms(): void
    {
        // Arrange: siapkan user, subscription & device sesuai factory proyek Anda.
        // This test is a placeholder: adjust to your existing route & auth.

        // $user = User::factory()->create();
        // $this->actingAs($user, 'sanctum');
        // $resp = $this->postJson('/api/v1/licenses/issue', [...]);

        // Sementara, minimal assert struktur untuk mock/manual test:
        $this->markTestIncomplete('Hook this test to your real license issue endpoint & factories.');
    }
}
```

## 6) Security Notes

* Signature HMAC untuk /time hanya menandatangani angka epoch (dalam string). Client akan memverifikasi: `sig == base64(hmac_sha256(server_epoch_ms_string, secret))`.
* Pastikan APP_LICENSE_SECRET panjang & acak.
* Semua endpoint tetap di balik HTTPS.

# ACCEPTANCE CRITERIA

* GET /api/v1/time mengembalikan:

  * HTTP 200
  * JSON: { success: true, data: { server_epoch_ms:int, sig:string }, message, code, server_time }
  * Sig valid: base64(hmac_sha256((string)server_epoch_ms, APP_LICENSE_SECRET))
* Response issue license sekarang memiliki `expires_at_ms` (epoch ms) tanpa menghapus field lama.
* Build success, route terdaftar, dan minimal 1 Feature test untuk /time lulus.

# OPTIONAL (boleh di-skip jika out of scope)

* Tambahkan Swagger/OpenAPI annotation untuk /time & issue license.
* Tambahkan RateLimit ringan untuk /time (mis. throttle:60,1) jika ingin.

Proceed to implement now.

```

Setelah ini beres, lanjutkan prompt terpisah untuk **Flutter** agar:
- selalu pakai `expires_at_ms`,
- panggil `/time` untuk memperbarui anchor waktu tiap 12 jam/tiap app aktif,
- terapkan lock >72 jam offline + warning >48 jam seperti yang sudah kita bahas.
```
